---
layout: post
title: "内存泄露与内存溢出"
date: 2019-07-18 17:57:05
description: "内存泄露与内存溢出"
categories:
- Java
permalink: 内存泄露与内存溢出
---

##### 内存泄露（Memory Leak）
> 一个不再被程序使用的对象或变量还在内存中占有存储空间  
> 一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出

##### 内存溢出（Out Of Memory）
> 指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储`int`类型数据的存储空间，但是你却存储`long`类型的数据，那么结果就是内存不够用，此时就会报错OOM，即所谓的内存溢出。

1. `静态集合类`，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。

2. `各种连接`，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。

3. `变量不合理的作用域`，一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。

```vim
public class T {
  // 此时变量s与对象T的生命周期相同，调用set方法后s还不能被回收，造成了内存泄露
  private String s;
  public void set() {
    // 从网络中接受数据保存到s中
    readFromNet();
    // 从网络中接受数据保存到s中
    saveDB();
  }
}
```

4. `内部类持有外部类（闭包）`，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

5. `改变哈希值`，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。
