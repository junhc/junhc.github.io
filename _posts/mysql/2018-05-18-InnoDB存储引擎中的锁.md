---
layout: post
title: "InnoDB存储引擎中的锁"
date: 2018-05-18 15:35:30
description: "InnoDB存储引擎中的锁"
categories:
- MySQL
permalink: InnoDB存储引擎中的锁
---

##### 锁的类型

InnoDB存储引擎实现了如下两种标准的行级锁  

* 共享锁（S Lock），允许事务读一行数据。
* 排他锁（X Lock），允许事务删除或者更新一行数据。

InnoDB存储引擎支持多粒度锁定，这种锁定允许在行级上的锁和表级上的锁同时存在。  
为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，我们称之为`意向锁`。  
意向锁是表级别的锁，InnoDB存储引擎支持两种意向锁  

* 意向共享锁（IS Lock），事务想要获得一个表中某几行的共享锁。
* 意向排他锁（IX Lock），事务想要获得一个表中某几行的排他锁。

##### 锁的算法

InnoDB存储引擎有3种行锁的算法设计  

* Record Lock：单个行记录上的锁
> Record Lock总是会去锁住索引记录。如果InnoDB存储引擎表建立的时候没有设置任何一个索引，  
> 这时InnoDB存储引擎会使用隐式的主键来进行锁定

* Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
* Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身

![](/assets/img/Next-Key Lock.png)

##### 多版本并发控制（MVCC）

可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。  
虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。  

MVCC的实现，是通过报存数据在某个时间点的快照来实现的。  
也就是说不管需要执行多长时间，每个事务看到的数据都是一致的。  
根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。  

InnoDB的MVCC，是通过在每行记录后面报错两个隐藏的列来实现的。  
这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。  
当然存储的并不是实际的时间值，而是系统版本号。  
每开始一个新的事务，系统版本号都会自动递增。  
事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。  

* SELECT
> InnoDB会根据以下两个条件检查每行记录  
> a. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号）  
> 这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。  
> b. 行的删除版本要么未定义，要么大于当前事务版本号。这个可以确保事务读取到的行，在事务开始之前未必删除。

* INSERT
> InnoDB为新插入的每一行保存当前系统版本号作为行版本号。  

* DELETE
> InnoDB为删除的每一行保存当前系统版本号作为删除标识。  

* UPDATE
> InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，  
> 同时保存当前系统版本号到原来的行作为删除标识。

MVCC只在`RR`和`RC`两个隔离级别下工作。
