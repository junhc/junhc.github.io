---
layout: post
title: "MySQL开发技巧"
date: 2015-08-21 14:32:48
description: "MySQL开发技巧"
categories:
- MySQL
permalink: mysql
---

#### Mac如何卸载MySQL
```vim
$ rm /usr/local/mysql
$ rm -rf /usr/local/mysql*
$ rm -rf /Library/PreferencePanes/My*
$ rm -rf /var/db/receipts/com.mysql.*
```

#### Mac重装MySQL
官网下载: [http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/)

#### 错误锦集
```vim
"ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement."
mysql> set password=password('123456');
```

#### MySQL事务隔离级别

```vim
//查看事务级别
select @@tx_isolation;
//设置事务级别
set transaction isolation level [read uncommitted][read committed][repeatable read][serializable];
//开始事务
start transaction;
//回滚
rollback;
//提交
commit;
```

```vim
一个事务本质上有四个特点ACID：

原子性（Atomicity）：原子性任务是一个独立的操作单元，是一种要么全部是，要么全部不是的原子单位性的操作。

一致性（Consistency）：一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。

一致性有下面特点：

如果一个操作触发辅助操作（级联，触发器），这些也必须成功，否则交易失败。
如果系统是由多个节点组成，一致性规定所有的变化必须传播到所有节点（多主复制）。如果从站节点是异步更新，那么我们打破一致性规则，系统成为“最终一致性”。
一个事务是数据状态的切换，因此，如果事务是并发多个，系统也必须如同串行事务一样操作。
在现实中，事务系统遭遇并发请求时，这种串行化是有成本的， Amdahl法则描述如下：它是描述序列串行执行和并发之间的关系。

“一个程序在并行计算情况下使用多个处理器所能提升的速度是由这个程序中串行执行部分的时间决定的。”

大多数数据库管理系统选择（默认情况下）是放宽一致性，以达到更好的并发性

隔离性（Isolaction）：事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。

耐久性（Durability）：一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中。如果我们的系统突然受到系统崩溃或断电，那么所有未完成已提交的事务可能会重演。


SQL标准规定了四个隔离水平：

READ_UNCOMMITTED
READ_COMMITTED
REPETABLE_READ
SERIALIZABLE
+----------------------------------------------------------------+
隔离级别            脏读             非重复读	       Phantom read   
+----------------------------------------------------------------+
READ_UNCOMMITTED   allowed		    allowed		   allowed        
+----------------------------------------------------------------+
READ_COMMITTED     prevented	    allowed		   allowed        
+----------------------------------------------------------------+
REPETABLE_READ     prevented	    prevented	   allowed        
+----------------------------------------------------------------+
SERIALIZABLE       prevented	    prevented	   prevented      
+----------------------------------------------------------------+

Read Uncommitted（读取未提交内容）
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多。
读取未提交的数据，也被称之为脏读（Dirty Read）。

Read Committed（读取提交内容）
这是大多数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例再该实例处理期间可能会有新的Commit，所以同一Select可能返回不同的结果。

Repeatable Read（可重读）
这是MySQL默认的事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这回导致另一个棘手的问题：幻读（Phantom Read）。
简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。InnoDB和Falcon存储引擎
通过多版本并发控制机制解决了该问题。

Serializable（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能互相冲突，从而解决幻读问题。简言之，它是在每个读的数据行加共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。
例如：
脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
不可重复读（Non-repeatable read）：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
幻读（Phantom Read）：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

脏读
脏读发生在：当一个事务允许读取一个被其他事务改变但是未提交的状态时，这是因为并没有锁阻止读取，如上图，你看到第二个事务读取了一个并不一致的值，不一致的意思是，这个值是无效的，因为修改这个值的第一个事务已经回滚，也就是说，第一个事务修改了这个值，但是未提交确认，却被第二个事务读取，第一个事务又放弃修改，悔棋了，而第二个事务就得到一个脏数据。

非重复读
反复读同一个数据却得到不同的结果，这是因为在反复几次读取的过程中，数据被修改了，这就导致我们使用了stale数据，这可以通过一个共享读锁来避免。这是隔离级别READ_COMMITTED会导致可重复读的原因。设置共享读锁也就是隔离级别提高到REPETABLE_READ。

Phantom读
当第二个事务插入一行记录，而正好之前第一个事务查询了应该包含这个新纪录的数据，那么这个查询事务的结果里肯定没有包含这个刚刚新插入的数据，这时幻影读发生了，通过变化锁和predicate locking避免。

```

#### MySQL返回自增长ID的四种方法
```vim
1.SELECT MAX(_ID) FROM TABLE_NAME;	
// 高并发下MAX(_ID)显然不能使用，这时可以使用LAST_INSERT_ID
// 因为LAST_INSERT_ID是基于Connection的，只要每个线程都使用独立的Connection对象，
// LAST_INSERT_ID函数将返回该Connection对AUTO_INCREMENT列最新的INSERT or UPDATE操作生成的第一个RECORD的ID。
// 这个值不能被其它客户端（Connection）影响，保证了你能够找回自己的ID而不用担心其它客户端的活动，而且不需要加锁。
// 使用单INSERT语句插入多条记录, LAST_INSERT_ID返回一个列表。

2.SELECT LAST_INSERT_ID();		
// LAST_INSERT_ID与TABLE无关的，如果向表A插入数据后，再向表B插入数据，LAST_INSERT_ID会改变。

3.SELECT @@IDENTITY;			
// @@IDENTITY表示的是最近一次向具有IDENTITY属性(即自增列)的表插入数据时对应的自增列的值，是系统定义的全局变量。
// 一般系统定义的全局变量都是以@@开头，用户自定义变量以@开头。
// 如有个表A，它的自增列是ID，当向A表插入一行数据后，如果插入数据后自增列的值自动增加至101，则通过SELECT @@IDENTITY得到的值就是101。
// 使用@@IDENTITY的前提是在进行INSERT操作后，执行SELECT @@IDENTITY的时候连接没有关闭，否则得到的是NULL值。

4.SHOW TABLE STATUS;			
// 得出的结果里边对应表名记录中有个AUTO_INCREMENT字段，里边有下一个自增ID的数值就是当前该表的最大自增ID
```
