---
layout: post
title: "Failure"
date: 2015-12-09 22:09:30
description: "Nothing Succeeds Like Failure."
categories:
- blog
permalink: failure
---

时间,2015年12月08日19点30分.  
事件,16分钟的电话面试.  
人物, 被问残了的我.  
记住这一时刻吧.

1.JVM内存管理与垃圾回收机制?

2.Java多线程中的信号量?  
>  CountDownLatch / CyclicBarrier / Semaphore.

```vim
java.lang.Object
	|_ java.util.concurrent.CountDownLatch

用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。

CountDownLatch 的一个有用特性是，它不要求调用 countDown 方法的线程等到计数到达零时才继续，而在所有线程都能通过之前，它只是阻止任何线程继续通过一个 await。

示例用法  
第一个类是一个启动信号，在 driver 为继续执行 worker 做好准备之前，它会阻止所有的 worker 继续执行。  
第二个类是一个完成信号，它允许 driver 在完成所有 worker 之前一直等待。

 class Driver { // ...
   void main() throws InterruptedException {
     CountDownLatch startSignal = new CountDownLatch(1);
     CountDownLatch doneSignal = new CountDownLatch(N);

     for (int i = 0; i < N; ++i) // 创建并启动线程
       new Thread(new Worker(startSignal, doneSignal)).start();

     doSomethingElse();            //
     startSignal.countDown();      // 计数到达零,释放所有等待线程
     doSomethingElse();
     doneSignal.await();           // 主线程在锁存器倒计数至零之前一直等待..
   }
 }

 class Worker implements Runnable {
   private final CountDownLatch startSignal;
   private final CountDownLatch doneSignal;
   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
      this.startSignal = startSignal;
      this.doneSignal = doneSignal;
   }
   public void run() {
      try {
        startSignal.await();	// 线程在锁存器倒计数至零之前一直等待..
        doWork();
        doneSignal.countDown();
	} catch (InterruptedException ex) {} // return;
   }

   void doWork() { ... }
 }

另一种典型用法是，将一个问题分成 N 个部分，用执行每个部分并让锁存器倒计数的 Runnable 来描述每个部分，然后将所有 Runnable 加入到 Executor 队列。当所有的子部分完成后，协调线程就能够通过 await。（当线程必须用这种方法反复倒计数时，可改为使用 CyclicBarrier。）

 class Driver2 { // ...
   void main() throws InterruptedException {
     CountDownLatch doneSignal = new CountDownLatch(N);
     Executor e = ...

     for (int i = 0; i < N; ++i) // 创建并启动线程
       e.execute(new WorkerRunnable(doneSignal, i));

     doneSignal.await();           // 线程在锁存器倒计数至零之前一直等待
   }
 }

 class WorkerRunnable implements Runnable {
   private final CountDownLatch doneSignal;
   private final int i;
   WorkerRunnable(CountDownLatch doneSignal, int i) {
      this.doneSignal = doneSignal;
      this.i = i;
   }
   public void run() {
      try {
        doWork(i);
        doneSignal.countDown();
      } catch (InterruptedException ex) {} // return;
   }

   void doWork() { ... }
 }


构造方法摘要
CountDownLatch(int count) 
	构造一个用给定计数初始化的 CountDownLatch。
方法摘要
void await()
	使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。  
boolean	await(long timeout, TimeUnit unit) 
	使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。  
void countDown()
	递减锁存器的计数，如果计数到达零，则释放所有等待的线程。  
long getCount()
	返回当前计数。  
String toString()
	返回标识此锁存器及其状态的字符串。  

```  
  
```vim
java.lang.Object
	|_ java.util.concurrent.CyclicBarrier

一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。

CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作 很有用。

示例用法

 class Solver {
   final int N;
   final float[][] data;
   final CyclicBarrier barrier;
   
   class Worker implements Runnable {
     int myRow;
     Worker(int row) { myRow = row; }
     public void run() {
       while (!done()) {
         processRow(myRow);

         try {
           barrier.await(); 
         } catch (InterruptedException ex) { 
		return; 
         } catch (BrokenBarrierException ex) { 
		return; 
         }
       }
     }
   }

   public Solver(float[][] matrix) {
     data = matrix;
     N = matrix.length;
     barrier = new CyclicBarrier(N, 
                                 new Runnable() {
                                   public void run() { 
                                     mergeRows(...); 
                                   }
                                 });
     for (int i = 0; i < N; ++i) 
       new Thread(new Worker(i)).start();

     waitUntilDone();
   }
 }
```  
3.Synchronized与Lock的区别?

4.Java线程池原理?

5.HashMap非线程安全,ConcurrentHashMap又是如何确保线程安全呢?

6.Hadoop?

7.MySQL B+/-Tree原理?

8.Memcached内存如何管理?

9.IO/NIO模型?

10.MySQL 事务隔离级别,乐观锁与悲观锁?

11.一致性Hash算法?  
      
> Steve Jobs, Apple Founder: Nothing Succeeds Like Failure.
