---
layout: post
title: "七周七并发编程"
date: 2016-04-23 15:55:35
description: "七周七并发编程"
categories:
- java
permalink: java
---  

### ConcurrentHashMap  
HashMap是非线程安全的,
Hashtable是线程安全的,但是Hashtable是采用synchonized进行同步的,相当于所有线程进行读写时,都去竞争一把锁,导致效率非常低下.  

ConcurrentHashMap可以做到读取数据不加锁,并且其内部结构可以让其在进行写操作的时候,能够将锁的粒度保持的尽量的小,不用对整个ConcurrentHashMap加锁.  

ConcurrentHashMap为了提高本身的并发能力,在内部采用了一个叫做Segment的结构,一个Segment其实就是一个类Hash Table的结构,  
Segment内部维护了一个链表数组.

ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作,第一次Hash定位到Segment,第二次Hash定位元素所在的链表的头部.  
因此,这一种结构带来的副作用就是Hash过程比普通的HashMap要长,但是带来的好处是写操作的时候可以只对元素所在Segment进行加锁,  
不会影响到其他的Segment.这样,在最理想的情况下,ConcurrentHashMap可以最高同时支持Segment数量大小的写操作  
(刚好这些写操作都非常平均的分布在所有的Segment上),所以,ConcurrentHashMap的并发能力可以大大的提高.

### Segment数据结构  
```vim
static final class Segment<K,V> extands ReentrantLock implements Serializable {
    transient volatile int count; //Segment中元素的数量
    transient int modCount;//对table的大小造成影响的操作数量(如:put,reomve操作)
    transient int threshold;//阈值,Segment里面元素的数量超过这个值依旧就会对Segment进行扩容
    transient volatile HashEntry<K,V>[] table;//链表数据,数组中的每一个元素代表了一个链表的头部
    final float loadFactor;//负载因子,用于确定threshold
}
```

### HashEntry  
```vim
static final class HashEntry<K,V> {
    final K key;
    final int hash;
    volatile V value;//其他的几个变量都是final的,这样做是为了防止链表结构被破坏,出现ConcurrentModification的情况
    final HashEntry<K,V> next;
}
```

### ConcurrentHashMap  
```vim
public ConcurrentHashMap(int initialCapacity, //初始的容量
                         float loadFactor, //负载参数
                         int concurrencyLevel //内部Segment的数量,ConcurrentLevel一经指定,不可改变,后续如果ConcurrentHashMap
                         的元素数量增加导致ConcurrentHashMap需要扩容,不会增加Segment的数量,只会增加Segment中链表数组的容量.
                         这样的好处是扩容不需要对整个ConcurrentHashMap做rehash,而只需要对Segment里面的元素做一次rehash.
                        ) {
    if(!(localFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
      throw new IllegalArgumentException();
      
    if(concurrencyLevel > MAX_SEGMENTS)
      concurrencyLevel = MAX_SEGMENTS;
    
    int sshift = 0;
    int ssize = 0;
    while (ssize < concurrencyLevel) {
      ++sshift;
      ssize <<= 1;
    }
    segmentShift = 32 - sshift;
    segmentMask = ssize - 1;
    this.segments = Segment.newArray(ssize);
    
    if (initialCapacity > MAXIMUM_CAPACITY)
      initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
       ++c;
    int cap = 1;
    while (cap < c)
      cap <<= 1;
    
    for (int i = 0; i < this.segments.length; ++i)
      this.segments[i] = new Segment<K,V>(cap, loadFactor);
}
```
