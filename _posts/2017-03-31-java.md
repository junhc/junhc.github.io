---
layout: post
title: "Java基础"
date: 2017-03-31 00:00:00
description: "Java基础"
categories:
- java
permalink: java
---

### 目录
* [1. 深究字符串String类](#1-深究字符串string类)
* [2. 关于ArrayList常见问题](#2-关于arraylist常见问题)
* [3. LinkedList](#3-linkedlist)

#### 1. 深究字符串String类  
##### 1.1 重载运算符 “+” 与 StringBuilder 的冤缘
```vim
public class T {
    public static void main(String[] args) {
       String a = "-";
       String b = "123" + a + "456" + a + 789;
       System.out.println(b);
    }
}

// 使用JDK自带javap命令生成字节码 javap -c T.class 

public class T {
  public T();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // String -
       2: astore_1
       3: new           #3                  // class java/lang/StringBuilder -- 编译器自动引用java.lang.StringBuilder类, 并实例化了一个StringBuilder对象
       6: dup
       7: invokespecial #4                  // Method java/lang/StringBuilder."<init>":()V
      10: ldc           #5                  // String 123 -- 每个运算符 "+" 调用一次 append 方法
      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      15: aload_1
      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      19: ldc           #7                  // String 456
      21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      24: aload_1
      25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      28: sipush        789
      31: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      34: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String; -- 最后调用 toString 方法, 返回String
      37: astore_2
      38: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream;
      41: aload_2
      42: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      45: return
}

// 再看看循环使用运算符 "+"  

public class T {
    public static void main(String[] args) {
       String a = "";
       for(int i=0; i<10; i++) {
          a += i;
       }
       System.out.println(a);
    }
}

public class T {
  public T();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // String
       2: astore_1
       3: iconst_0
       4: istore_2
       5: iload_2 -- 循环开始..
       6: bipush        10
       8: if_icmpge     36
      11: new           #3                  // class java/lang/StringBuilder -- 每次循环都会实例化一个StringBuilder对象
      14: dup
      15: invokespecial #4                  // Method java/lang/StringBuilder."<init>":()V
      18: aload_1
      19: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      22: iload_2
      23: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      26: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      29: astore_1
      30: iinc          2, 1
      33: goto          5  -- 跳转到第5行..
      36: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;
      39: aload_1
      40: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      43: return
}
```

#### 2. 关于ArrayList常见问题   
##### 2.1 ArrayList的扩容机制  

```vim
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final int DEFAULT_CAPACITY = 10;
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private transient Object[] elementData;
    private int size;
    
    ...
    // 继承自AbstractList, 记录size变化的次数
    protected transient int	modCount;
    ...
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
    
    private void ensureCapacityInternal(int minCapacity) {
        if (elementData == EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
    
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }

    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }
}

public final class System {
   /**
   * 源数组中位置在 srcPos 到 srcPos+length-1 之间的元素被复制到目标数组中的 destPos 到 destPos+length-1 位置.
   * @param      src      源数组.
   * @param      srcPos   源数组中的起始位置, 若 srcPos+length 大于 src.length，则抛出 IndexOutOfBoundsException 异常
   * @param      dest     目标数组.
   * @param      destPos  目标数组中的起始位置, 若 destPos+length 大于 dest.length，则抛出 IndexOutOfBoundsException 异常
   * @param      length   要复制的数组元素的数量.
   */
   public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length){}
}
```
##### 2.2 ArrayList是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高，但插入和删除操作时，要移动数据效率比较低

#### 3. LinkedList  
##### 3.1 LinkedList基于链表的数据结构，地址是任意，所以在开辟内存空间的时候不需要等一个连续的地址，对于插入和删除操作效率会比较高，但查询操作时，要移动指针效率比较低
```vim
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{
    transient int size = 0;
    // Pointer to first node.
    transient Node<E> first; 
    // Pointer to last node.
    transient Node<E> last;
    
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
    
    /**
     * Links e as first element.
     */
    private void linkFirst(E e) {
        final Node<E> f = first;
        final Node<E> newNode = new Node<>(null, e, f);
        first = newNode;
        if (f == null)
            last = newNode;
        else
            f.prev = newNode;
        size++;
        modCount++;
    }

    /**
     * Links e as last element.
     */
    void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }

    /**
     * Returns the element at the specified position in this list.
     *
     * @param index index of the element to return
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }

    /**
     * Returns the (non-null) Node at the specified element index.
     */
    Node<E> node(int index) {
        // assert isElementIndex(index);

        if (index < (size >> 1)) {
            Node<E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }

    public E remove(int index) {
        checkElementIndex(index);
        return unlink(node(index));
    }
    
     /**
     * Unlinks non-null node x.
     */
    E unlink(Node<E> x) {
        // assert x != null;
        final E element = x.item;
        final Node<E> next = x.next;
        final Node<E> prev = x.prev;

        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }

        x.item = null;
        size--;
        modCount++;
        return element;
    }    
}
```
##### 适用场景分析
> 当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList
