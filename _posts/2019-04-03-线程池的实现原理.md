---
layout: post
title: "线程池的实现原理"
date: 2019-04-03 14:32:48
description: "线程池的实现原理"
categories:
- java
permalink: threadpool
---

##### 线程池的处理流程
> 1) 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。  
如果核心线程池里的线程都在执行任务，则进入下个流程。  

> 2) 线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。  
如果工作队列满了，则进入下个流程。  

> 3) 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。  
如果已经满了，则交给饱和策略来处理这个任务。

```vim
public class ThreadPoolExecutor extends AbstractExecutorService {

  public void execute(Runnable command) {
      if (command == null)
          throw new NullPointerException();
      // 1. 如果线程数小于基本线程数，则创建线程并执行当前任务
      // 2. 如线程数大于等于基本线程或线程创建失败，则将当前任务放到工作队列中
      // 3. 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，
      // 则创建一个线程执行任务  
      int c = ctl.get();
      if (workerCountOf(c) < corePoolSize) {
          if (addWorker(command, true))
              return;
          c = ctl.get();
      }
      if (isRunning(c) && workQueue.offer(command)) {
          int recheck = ctl.get();
          if (! isRunning(recheck) && remove(command))
              reject(command);
          else if (workerCountOf(recheck) == 0)
              addWorker(null, false);
      }
      else if (!addWorker(command, false))
          reject(command);
  }
...
}
```

##### 线程池的使用
```vim
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```
> 1) `corePoolSize(线程池的基本大小)`：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，  
> 即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。  
> 如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。  

> 2) `runnableTaskQueue(任务队列)`：用于保存等待执行的任务的阻塞队列。  
  * a. ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列。  
  * b. LinkedBlockingQueue：一个基于链表结构的阻塞队列。吞吐量通常要高于ArrayBlockingQueue。  
  * c. SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。  
  * d. PriorityBlockingQueue：一个具有优先级的无线阻塞队列。  

> 3) `maximumPoolSize(线程池最大数量)`：线程池允许创建的最大线程数。如果队列满了，  
> 并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果是使用了无界的任务队列，这个参数就没什么效果。  

> 4) `ThreadFactory`：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。  

> 5) `RejectedExecutionHandler(饱和策略)`：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。  
  * a. AbortPolicy：直接抛出异常  
  * b. CallerRunsPolicy：只用调用者所在线程来运行任务  
  * c. DiscardOldestPolicy：丢弃队里最近的一个任务，并执行当前任务  
  * e. DiscardPolicy：不处理，丢弃掉  

> 6) `keepAliveTime(线程活动保持时间)`：线程池的工作线程空闲后，保持存活的时间。  
所以如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提供线程的利用率。  

> 7) `TimeUnit(线程活动保持时间的单位)`
